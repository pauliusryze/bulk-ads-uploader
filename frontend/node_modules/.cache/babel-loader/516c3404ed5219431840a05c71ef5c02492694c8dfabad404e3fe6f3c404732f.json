{"ast":null,"code":"import { defaultDateLib } from \"../classes/DateLib.js\";\nimport { dateMatchModifiers } from \"./dateMatchModifiers.js\";\nimport { rangeContainsDayOfWeek } from \"./rangeContainsDayOfWeek.js\";\nimport { rangeIncludesDate } from \"./rangeIncludesDate.js\";\nimport { rangeOverlaps } from \"./rangeOverlaps.js\";\nimport { isDateAfterType, isDateBeforeType, isDateInterval, isDateRange, isDatesArray, isDayOfWeekType } from \"./typeguards.js\";\n/**\n * Checks if a date range contains dates that match the given modifiers.\n *\n * @since 9.2.2\n * @param range - The date range to check.\n * @param modifiers - The modifiers to match against.\n * @param dateLib - The date utility library instance.\n * @returns `true` if the range contains matching dates, otherwise `false`.\n * @group Utilities\n */\nexport function rangeContainsModifiers(range, modifiers) {\n  let dateLib = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultDateLib;\n  const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];\n  // Defer function matchers evaluation as they are the least performant.\n  const nonFunctionMatchers = matchers.filter(matcher => typeof matcher !== \"function\");\n  const nonFunctionMatchersResult = nonFunctionMatchers.some(matcher => {\n    if (typeof matcher === \"boolean\") return matcher;\n    if (dateLib.isDate(matcher)) {\n      return rangeIncludesDate(range, matcher, false, dateLib);\n    }\n    if (isDatesArray(matcher, dateLib)) {\n      return matcher.some(date => rangeIncludesDate(range, date, false, dateLib));\n    }\n    if (isDateRange(matcher)) {\n      if (matcher.from && matcher.to) {\n        return rangeOverlaps(range, {\n          from: matcher.from,\n          to: matcher.to\n        }, dateLib);\n      }\n      return false;\n    }\n    if (isDayOfWeekType(matcher)) {\n      return rangeContainsDayOfWeek(range, matcher.dayOfWeek, dateLib);\n    }\n    if (isDateInterval(matcher)) {\n      const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);\n      if (isClosedInterval) {\n        return rangeOverlaps(range, {\n          from: dateLib.addDays(matcher.after, 1),\n          to: dateLib.addDays(matcher.before, -1)\n        }, dateLib);\n      }\n      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);\n    }\n    if (isDateAfterType(matcher) || isDateBeforeType(matcher)) {\n      return dateMatchModifiers(range.from, matcher, dateLib) || dateMatchModifiers(range.to, matcher, dateLib);\n    }\n    return false;\n  });\n  if (nonFunctionMatchersResult) {\n    return true;\n  }\n  const functionMatchers = matchers.filter(matcher => typeof matcher === \"function\");\n  if (functionMatchers.length) {\n    let date = range.from;\n    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);\n    for (let i = 0; i <= totalDays; i++) {\n      if (functionMatchers.some(matcher => matcher(date))) {\n        return true;\n      }\n      date = dateLib.addDays(date, 1);\n    }\n  }\n  return false;\n}","map":{"version":3,"names":["defaultDateLib","dateMatchModifiers","rangeContainsDayOfWeek","rangeIncludesDate","rangeOverlaps","isDateAfterType","isDateBeforeType","isDateInterval","isDateRange","isDatesArray","isDayOfWeekType","rangeContainsModifiers","range","modifiers","dateLib","arguments","length","undefined","matchers","Array","isArray","nonFunctionMatchers","filter","matcher","nonFunctionMatchersResult","some","isDate","date","from","to","dayOfWeek","isClosedInterval","isAfter","before","after","addDays","functionMatchers","totalDays","differenceInCalendarDays","i"],"sources":["/Users/paulius/Downloads/Projects/Meta Ads Uploader/frontend/node_modules/react-day-picker/src/utils/rangeContainsModifiers.ts"],"sourcesContent":["import { defaultDateLib, type DateLib } from \"../classes/DateLib.js\";\nimport type { Matcher } from \"../types/index.js\";\n\nimport { dateMatchModifiers } from \"./dateMatchModifiers.js\";\nimport { rangeContainsDayOfWeek } from \"./rangeContainsDayOfWeek.js\";\nimport { rangeIncludesDate } from \"./rangeIncludesDate.js\";\nimport { rangeOverlaps } from \"./rangeOverlaps.js\";\nimport {\n  isDateAfterType,\n  isDateBeforeType,\n  isDateInterval,\n  isDateRange,\n  isDatesArray,\n  isDayOfWeekType\n} from \"./typeguards.js\";\n\n/**\n * Checks if a date range contains dates that match the given modifiers.\n *\n * @since 9.2.2\n * @param range - The date range to check.\n * @param modifiers - The modifiers to match against.\n * @param dateLib - The date utility library instance.\n * @returns `true` if the range contains matching dates, otherwise `false`.\n * @group Utilities\n */\nexport function rangeContainsModifiers(\n  range: { from: Date; to: Date },\n  modifiers: Matcher | Matcher[],\n  dateLib: DateLib = defaultDateLib\n): boolean {\n  const matchers = Array.isArray(modifiers) ? modifiers : [modifiers];\n\n  // Defer function matchers evaluation as they are the least performant.\n  const nonFunctionMatchers = matchers.filter(\n    (matcher) => typeof matcher !== \"function\"\n  );\n\n  const nonFunctionMatchersResult = nonFunctionMatchers.some((matcher) => {\n    if (typeof matcher === \"boolean\") return matcher;\n\n    if (dateLib.isDate(matcher)) {\n      return rangeIncludesDate(range, matcher, false, dateLib);\n    }\n\n    if (isDatesArray(matcher, dateLib)) {\n      return matcher.some((date) =>\n        rangeIncludesDate(range, date, false, dateLib)\n      );\n    }\n\n    if (isDateRange(matcher)) {\n      if (matcher.from && matcher.to) {\n        return rangeOverlaps(\n          range,\n          { from: matcher.from, to: matcher.to },\n          dateLib\n        );\n      }\n      return false;\n    }\n\n    if (isDayOfWeekType(matcher)) {\n      return rangeContainsDayOfWeek(range, matcher.dayOfWeek, dateLib);\n    }\n\n    if (isDateInterval(matcher)) {\n      const isClosedInterval = dateLib.isAfter(matcher.before, matcher.after);\n      if (isClosedInterval) {\n        return rangeOverlaps(\n          range,\n          {\n            from: dateLib.addDays(matcher.after, 1),\n            to: dateLib.addDays(matcher.before, -1)\n          },\n          dateLib\n        );\n      }\n      return (\n        dateMatchModifiers(range.from, matcher, dateLib) ||\n        dateMatchModifiers(range.to, matcher, dateLib)\n      );\n    }\n\n    if (isDateAfterType(matcher) || isDateBeforeType(matcher)) {\n      return (\n        dateMatchModifiers(range.from, matcher, dateLib) ||\n        dateMatchModifiers(range.to, matcher, dateLib)\n      );\n    }\n\n    return false;\n  });\n\n  if (nonFunctionMatchersResult) {\n    return true;\n  }\n\n  const functionMatchers = matchers.filter(\n    (matcher) => typeof matcher === \"function\"\n  );\n\n  if (functionMatchers.length) {\n    let date = range.from;\n    const totalDays = dateLib.differenceInCalendarDays(range.to, range.from);\n\n    for (let i = 0; i <= totalDays; i++) {\n      if (functionMatchers.some((matcher) => matcher(date))) {\n        return true;\n      }\n      date = dateLib.addDays(date, 1);\n    }\n  }\n\n  return false;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}