{"ast":null,"code":"\"use client\";\n\n// src/toast.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport * as DismissableLayer from \"@radix-ui/react-dismissable-layer\";\nimport { Portal } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { VisuallyHidden } from \"@radix-ui/react-visually-hidden\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(\"Toast\");\nvar [createToastContext, createToastScope] = createContextScope(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\nvar ToastProvider = props => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n  if (!label.trim()) {\n    console.error(`Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`);\n  }\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: __scopeToast,\n    children: /* @__PURE__ */jsx(ToastProviderProvider, {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount(prevCount => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount(prevCount => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    })\n  });\n};\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    hotkey = VIEWPORT_DEFAULT_HOTKEY,\n    label = \"Notifications ({hotkey})\",\n    ...viewportProps\n  } = props;\n  const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n  const getItems = useCollection(__scopeToast);\n  const wrapperRef = React.useRef(null);\n  const headFocusProxyRef = React.useRef(null);\n  const tailFocusProxyRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n  const hasToasts = context.toastCount > 0;\n  React.useEffect(() => {\n    const handleKeyDown = event => {\n      const isHotkeyPressed = hotkey.length !== 0 && hotkey.every(key => event[key] || event.code === key);\n      if (isHotkeyPressed) ref.current?.focus();\n    };\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [hotkey]);\n  React.useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const viewport = ref.current;\n    if (hasToasts && wrapper && viewport) {\n      const handlePause = () => {\n        if (!context.isClosePausedRef.current) {\n          const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n          viewport.dispatchEvent(pauseEvent);\n          context.isClosePausedRef.current = true;\n        }\n      };\n      const handleResume = () => {\n        if (context.isClosePausedRef.current) {\n          const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n          viewport.dispatchEvent(resumeEvent);\n          context.isClosePausedRef.current = false;\n        }\n      };\n      const handleFocusOutResume = event => {\n        const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n        if (isFocusMovingOutside) handleResume();\n      };\n      const handlePointerLeaveResume = () => {\n        const isFocusInside = wrapper.contains(document.activeElement);\n        if (!isFocusInside) handleResume();\n      };\n      wrapper.addEventListener(\"focusin\", handlePause);\n      wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n      wrapper.addEventListener(\"pointermove\", handlePause);\n      wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n      window.addEventListener(\"blur\", handlePause);\n      window.addEventListener(\"focus\", handleResume);\n      return () => {\n        wrapper.removeEventListener(\"focusin\", handlePause);\n        wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.removeEventListener(\"pointermove\", handlePause);\n        wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.removeEventListener(\"blur\", handlePause);\n        window.removeEventListener(\"focus\", handleResume);\n      };\n    }\n  }, [hasToasts, context.isClosePausedRef]);\n  const getSortedTabbableCandidates = React.useCallback(_ref => {\n    let {\n      tabbingDirection\n    } = _ref;\n    const toastItems = getItems();\n    const tabbableCandidates = toastItems.map(toastItem => {\n      const toastNode = toastItem.ref.current;\n      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n      return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n    });\n    return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n  }, [getItems]);\n  React.useEffect(() => {\n    const viewport = ref.current;\n    if (viewport) {\n      const handleKeyDown = event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n        if (isTabKey) {\n          const focusedElement = document.activeElement;\n          const isTabbingBackwards = event.shiftKey;\n          const targetIsViewport = event.target === viewport;\n          if (targetIsViewport && isTabbingBackwards) {\n            headFocusProxyRef.current?.focus();\n            return;\n          }\n          const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n          const sortedCandidates = getSortedTabbableCandidates({\n            tabbingDirection\n          });\n          const index = sortedCandidates.findIndex(candidate => candidate === focusedElement);\n          if (focusFirst(sortedCandidates.slice(index + 1))) {\n            event.preventDefault();\n          } else {\n            isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();\n          }\n        }\n      };\n      viewport.addEventListener(\"keydown\", handleKeyDown);\n      return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n    }\n  }, [getItems, getSortedTabbableCandidates]);\n  return /* @__PURE__ */jsxs(DismissableLayer.Branch, {\n    ref: wrapperRef,\n    role: \"region\",\n    \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n    tabIndex: -1,\n    style: {\n      pointerEvents: hasToasts ? void 0 : \"none\"\n    },\n    children: [hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: headFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"forwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    }), /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeToast,\n      children: /* @__PURE__ */jsx(Primitive.ol, {\n        tabIndex: -1,\n        ...viewportProps,\n        ref: composedRefs\n      })\n    }), hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: tailFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"backwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    })]\n  });\n});\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    onFocusFromOutsideViewport,\n    ...proxyProps\n  } = props;\n  const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(VisuallyHidden, {\n    \"aria-hidden\": true,\n    tabIndex: 0,\n    ...proxyProps,\n    ref: forwardedRef,\n    style: {\n      position: \"fixed\"\n    },\n    onFocus: event => {\n      const prevFocusedElement = event.relatedTarget;\n      const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n      if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n    }\n  });\n});\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    ...toastProps\n  } = props;\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? true,\n    onChange: onOpenChange,\n    caller: TOAST_NAME\n  });\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(ToastImpl, {\n      open,\n      ...toastProps,\n      ref: forwardedRef,\n      onClose: () => setOpen(false),\n      onPause: useCallbackRef(props.onPause),\n      onResume: useCallbackRef(props.onResume),\n      onSwipeStart: composeEventHandlers(props.onSwipeStart, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n      }),\n      onSwipeMove: composeEventHandlers(props.onSwipeMove, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", `${y}px`);\n      }),\n      onSwipeCancel: composeEventHandlers(props.onSwipeCancel, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n      }),\n      onSwipeEnd: composeEventHandlers(props.onSwipeEnd, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", `${y}px`);\n        setOpen(false);\n      })\n    })\n  });\n});\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {}\n});\nvar ToastImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    type = \"foreground\",\n    duration: durationProp,\n    open,\n    onClose,\n    onEscapeKeyDown,\n    onPause,\n    onResume,\n    onSwipeStart,\n    onSwipeMove,\n    onSwipeCancel,\n    onSwipeEnd,\n    ...toastProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [node, setNode] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const pointerStartRef = React.useRef(null);\n  const swipeDeltaRef = React.useRef(null);\n  const duration = durationProp || context.duration;\n  const closeTimerStartTimeRef = React.useRef(0);\n  const closeTimerRemainingTimeRef = React.useRef(duration);\n  const closeTimerRef = React.useRef(0);\n  const {\n    onToastAdd,\n    onToastRemove\n  } = context;\n  const handleClose = useCallbackRef(() => {\n    const isFocusInToast = node?.contains(document.activeElement);\n    if (isFocusInToast) context.viewport?.focus();\n    onClose();\n  });\n  const startTimer = React.useCallback(duration2 => {\n    if (!duration2 || duration2 === Infinity) return;\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerStartTimeRef.current = (/* @__PURE__ */new Date()).getTime();\n    closeTimerRef.current = window.setTimeout(handleClose, duration2);\n  }, [handleClose]);\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    if (viewport) {\n      const handleResume = () => {\n        startTimer(closeTimerRemainingTimeRef.current);\n        onResume?.();\n      };\n      const handlePause = () => {\n        const elapsedTime = (/* @__PURE__ */new Date()).getTime() - closeTimerStartTimeRef.current;\n        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n        window.clearTimeout(closeTimerRef.current);\n        onPause?.();\n      };\n      viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n      viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n      return () => {\n        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n      };\n    }\n  }, [context.viewport, duration, onPause, onResume, startTimer]);\n  React.useEffect(() => {\n    if (open && !context.isClosePausedRef.current) startTimer(duration);\n  }, [open, duration, context.isClosePausedRef, startTimer]);\n  React.useEffect(() => {\n    onToastAdd();\n    return () => onToastRemove();\n  }, [onToastAdd, onToastRemove]);\n  const announceTextContent = React.useMemo(() => {\n    return node ? getAnnounceTextContent(node) : null;\n  }, [node]);\n  if (!context.viewport) return null;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [announceTextContent && /* @__PURE__ */jsx(ToastAnnounce, {\n      __scopeToast,\n      role: \"status\",\n      \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n      \"aria-atomic\": true,\n      children: announceTextContent\n    }), /* @__PURE__ */jsx(ToastInteractiveProvider, {\n      scope: __scopeToast,\n      onClose: handleClose,\n      children: ReactDOM.createPortal(/* @__PURE__ */jsx(Collection.ItemSlot, {\n        scope: __scopeToast,\n        children: /* @__PURE__ */jsx(DismissableLayer.Root, {\n          asChild: true,\n          onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {\n            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n            context.isFocusedToastEscapeKeyDownRef.current = false;\n          }),\n          children: /* @__PURE__ */jsx(Primitive.li, {\n            role: \"status\",\n            \"aria-live\": \"off\",\n            \"aria-atomic\": true,\n            tabIndex: 0,\n            \"data-state\": open ? \"open\" : \"closed\",\n            \"data-swipe-direction\": context.swipeDirection,\n            ...toastProps,\n            ref: composedRefs,\n            style: {\n              userSelect: \"none\",\n              touchAction: \"none\",\n              ...props.style\n            },\n            onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n              if (event.key !== \"Escape\") return;\n              onEscapeKeyDown?.(event.nativeEvent);\n              if (!event.nativeEvent.defaultPrevented) {\n                context.isFocusedToastEscapeKeyDownRef.current = true;\n                handleClose();\n              }\n            }),\n            onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n              if (event.button !== 0) return;\n              pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n              };\n            }),\n            onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n              if (!pointerStartRef.current) return;\n              const x = event.clientX - pointerStartRef.current.x;\n              const y = event.clientY - pointerStartRef.current.y;\n              const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n              const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n              const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n              const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n              const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n              const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n              const delta = {\n                x: clampedX,\n                y: clampedY\n              };\n              const eventDetail = {\n                originalEvent: event,\n                delta\n              };\n              if (hasSwipeMoveStarted) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                  discrete: false\n                });\n              } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                  discrete: false\n                });\n                event.target.setPointerCapture(event.pointerId);\n              } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                pointerStartRef.current = null;\n              }\n            }),\n            onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n              const delta = swipeDeltaRef.current;\n              const target = event.target;\n              if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n              }\n              swipeDeltaRef.current = null;\n              pointerStartRef.current = null;\n              if (delta) {\n                const toast = event.currentTarget;\n                const eventDetail = {\n                  originalEvent: event,\n                  delta\n                };\n                if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                    discrete: true\n                  });\n                } else {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {\n                    discrete: true\n                  });\n                }\n                toast.addEventListener(\"click\", event2 => event2.preventDefault(), {\n                  once: true\n                });\n              }\n            })\n          })\n        })\n      }), context.viewport)\n    })]\n  });\n});\nvar ToastAnnounce = props => {\n  const {\n    __scopeToast,\n    children,\n    ...announceProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : /* @__PURE__ */jsx(Portal, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(VisuallyHidden, {\n      ...announceProps,\n      children: renderAnnounceText && /* @__PURE__ */jsxs(Fragment, {\n        children: [context.label, \" \", children]\n      })\n    })\n  });\n};\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...titleProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...titleProps,\n    ref: forwardedRef\n  });\n});\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...descriptionProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    ...descriptionProps,\n    ref: forwardedRef\n  });\n});\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef((props, forwardedRef) => {\n  const {\n    altText,\n    ...actionProps\n  } = props;\n  if (!altText.trim()) {\n    console.error(`Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`);\n    return null;\n  }\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    altText,\n    asChild: true,\n    children: /* @__PURE__ */jsx(ToastClose, {\n      ...actionProps,\n      ref: forwardedRef\n    })\n  });\n});\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...closeProps\n  } = props;\n  const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      ...closeProps,\n      ref: forwardedRef,\n      onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)\n    })\n  });\n});\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    altText,\n    ...announceExcludeProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"data-radix-toast-announce-exclude\": \"\",\n    \"data-radix-toast-announce-alt\": altText || void 0,\n    ...announceExcludeProps,\n    ref: forwardedRef\n  });\n});\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach(node => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\nfunction handleAndDispatchCustomEvent(name, handler, detail, _ref2) {\n  let {\n    discrete\n  } = _ref2;\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    cancelable: true,\n    detail\n  });\n  if (handler) currentTarget.addEventListener(name, handler, {\n    once: true\n  });\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\nvar isDeltaInDirection = function (delta, direction) {\n  let threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\nfunction useNextFrame() {\n  let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n}\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;\nexport { Action, Close, Description, Provider, Root2 as Root, Title, Toast, ToastAction, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, Viewport, createToastScope };","map":{"version":3,"names":["React","ReactDOM","composeEventHandlers","useComposedRefs","createCollection","createContextScope","DismissableLayer","Portal","Presence","Primitive","dispatchDiscreteCustomEvent","useCallbackRef","useControllableState","useLayoutEffect","VisuallyHidden","Fragment","jsx","jsxs","PROVIDER_NAME","Collection","useCollection","createCollectionScope","createToastContext","createToastScope","ToastProviderProvider","useToastProviderContext","ToastProvider","props","__scopeToast","label","duration","swipeDirection","swipeThreshold","children","viewport","setViewport","useState","toastCount","setToastCount","isFocusedToastEscapeKeyDownRef","useRef","isClosePausedRef","trim","console","error","Provider","scope","onViewportChange","onToastAdd","useCallback","prevCount","onToastRemove","displayName","VIEWPORT_NAME","VIEWPORT_DEFAULT_HOTKEY","VIEWPORT_PAUSE","VIEWPORT_RESUME","ToastViewport","forwardRef","forwardedRef","hotkey","viewportProps","context","getItems","wrapperRef","headFocusProxyRef","tailFocusProxyRef","ref","composedRefs","hotkeyLabel","join","replace","hasToasts","useEffect","handleKeyDown","event","isHotkeyPressed","length","every","key","code","current","focus","document","addEventListener","removeEventListener","wrapper","handlePause","pauseEvent","CustomEvent","dispatchEvent","handleResume","resumeEvent","handleFocusOutResume","isFocusMovingOutside","contains","relatedTarget","handlePointerLeaveResume","isFocusInside","activeElement","window","getSortedTabbableCandidates","_ref","tabbingDirection","toastItems","tabbableCandidates","map","toastItem","toastNode","toastTabbableCandidates","getTabbableCandidates","reverse","flat","isMetaKey","altKey","ctrlKey","metaKey","isTabKey","focusedElement","isTabbingBackwards","shiftKey","targetIsViewport","target","sortedCandidates","index","findIndex","candidate","focusFirst","slice","preventDefault","Branch","role","tabIndex","style","pointerEvents","FocusProxy","onFocusFromOutsideViewport","Slot","ol","FOCUS_PROXY_NAME","proxyProps","position","onFocus","prevFocusedElement","isFocusFromOutsideViewport","TOAST_NAME","TOAST_SWIPE_START","TOAST_SWIPE_MOVE","TOAST_SWIPE_CANCEL","TOAST_SWIPE_END","Toast","forceMount","open","openProp","defaultOpen","onOpenChange","toastProps","setOpen","prop","defaultProp","onChange","caller","present","ToastImpl","onClose","onPause","onResume","onSwipeStart","currentTarget","setAttribute","onSwipeMove","x","y","detail","delta","setProperty","onSwipeCancel","removeProperty","onSwipeEnd","ToastInteractiveProvider","useToastInteractiveContext","type","durationProp","onEscapeKeyDown","node","setNode","node2","pointerStartRef","swipeDeltaRef","closeTimerStartTimeRef","closeTimerRemainingTimeRef","closeTimerRef","handleClose","isFocusInToast","startTimer","duration2","Infinity","clearTimeout","Date","getTime","setTimeout","elapsedTime","announceTextContent","useMemo","getAnnounceTextContent","ToastAnnounce","createPortal","ItemSlot","Root","asChild","li","userSelect","touchAction","onKeyDown","nativeEvent","defaultPrevented","onPointerDown","button","clientX","clientY","onPointerMove","hasSwipeMoveStarted","Boolean","isHorizontalSwipe","includes","clamp","Math","min","max","clampedX","clampedY","moveStartBuffer","pointerType","eventDetail","originalEvent","handleAndDispatchCustomEvent","discrete","isDeltaInDirection","setPointerCapture","pointerId","abs","onPointerUp","hasPointerCapture","releasePointerCapture","toast","event2","once","announceProps","renderAnnounceText","setRenderAnnounceText","isAnnounced","setIsAnnounced","useNextFrame","timer","TITLE_NAME","ToastTitle","titleProps","div","DESCRIPTION_NAME","ToastDescription","descriptionProps","ACTION_NAME","ToastAction","altText","actionProps","ToastAnnounceExclude","ToastClose","CLOSE_NAME","closeProps","interactiveContext","onClick","announceExcludeProps","container","textContent","childNodes","Array","from","forEach","nodeType","TEXT_NODE","push","isHTMLElement","isHidden","ariaHidden","hidden","display","isExcluded","dataset","radixToastAnnounceExclude","radixToastAnnounceAlt","name","handler","_ref2","bubbles","cancelable","direction","threshold","arguments","undefined","deltaX","deltaY","isDeltaX","callback","fn","raf1","raf2","requestAnimationFrame","cancelAnimationFrame","ELEMENT_NODE","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","disabled","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","candidates","previouslyFocusedElement","some","Viewport","Root2","Title","Description","Action","Close"],"sources":["/Users/paulius/Downloads/Projects/Meta Ads Uploader/frontend/node_modules/@radix-ui/react-toast/src/toast.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ComponentRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `†` and `t !== †`\n        const isHotkeyPressed =\n          hotkey.length !== 0 && hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ComponentRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        aria-hidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen ?? true,\n      onChange: onOpenChange,\n      caller: TOAST_NAME,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ComponentRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n            aria-atomic\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  // Ensure toasts are announced as status list or status when focused\n                  role=\"status\"\n                  aria-live=\"off\"\n                  aria-atomic\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}