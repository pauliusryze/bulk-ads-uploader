{"ast":null,"code":"/**\n * Calculates the next date that should be focused in the calendar.\n *\n * This function determines the next focusable date based on the movement\n * direction, constraints, and calendar configuration.\n *\n * @param moveBy The unit of movement (e.g., \"day\", \"week\").\n * @param moveDir The direction of movement (\"before\" or \"after\").\n * @param refDate The reference date from which to calculate the next focusable\n *   date.\n * @param navStart The earliest date the user can navigate to.\n * @param navEnd The latest date the user can navigate to.\n * @param props The DayPicker props, including calendar configuration options.\n * @param dateLib The date library to use for date manipulation.\n * @returns The next focusable date.\n */\nexport function getFocusableDate(moveBy, moveDir, refDate, navStart, navEnd, props, dateLib) {\n  const {\n    ISOWeek,\n    broadcastCalendar\n  } = props;\n  const {\n    addDays,\n    addMonths,\n    addWeeks,\n    addYears,\n    endOfBroadcastWeek,\n    endOfISOWeek,\n    endOfWeek,\n    max,\n    min,\n    startOfBroadcastWeek,\n    startOfISOWeek,\n    startOfWeek\n  } = dateLib;\n  const moveFns = {\n    day: addDays,\n    week: addWeeks,\n    month: addMonths,\n    year: addYears,\n    startOfWeek: date => broadcastCalendar ? startOfBroadcastWeek(date, dateLib) : ISOWeek ? startOfISOWeek(date) : startOfWeek(date),\n    endOfWeek: date => broadcastCalendar ? endOfBroadcastWeek(date) : ISOWeek ? endOfISOWeek(date) : endOfWeek(date)\n  };\n  let focusableDate = moveFns[moveBy](refDate, moveDir === \"after\" ? 1 : -1);\n  if (moveDir === \"before\" && navStart) {\n    focusableDate = max([navStart, focusableDate]);\n  } else if (moveDir === \"after\" && navEnd) {\n    focusableDate = min([navEnd, focusableDate]);\n  }\n  return focusableDate;\n}","map":{"version":3,"names":["getFocusableDate","moveBy","moveDir","refDate","navStart","navEnd","props","dateLib","ISOWeek","broadcastCalendar","addDays","addMonths","addWeeks","addYears","endOfBroadcastWeek","endOfISOWeek","endOfWeek","max","min","startOfBroadcastWeek","startOfISOWeek","startOfWeek","moveFns","day","week","month","year","date","focusableDate"],"sources":["/Users/paulius/Downloads/Projects/Meta Ads Uploader/frontend/node_modules/react-day-picker/src/helpers/getFocusableDate.ts"],"sourcesContent":["import type { DateLib } from \"../classes/DateLib.js\";\nimport type {\n  DayPickerProps,\n  MoveFocusBy,\n  MoveFocusDir\n} from \"../types/index.js\";\n\n/**\n * Calculates the next date that should be focused in the calendar.\n *\n * This function determines the next focusable date based on the movement\n * direction, constraints, and calendar configuration.\n *\n * @param moveBy The unit of movement (e.g., \"day\", \"week\").\n * @param moveDir The direction of movement (\"before\" or \"after\").\n * @param refDate The reference date from which to calculate the next focusable\n *   date.\n * @param navStart The earliest date the user can navigate to.\n * @param navEnd The latest date the user can navigate to.\n * @param props The DayPicker props, including calendar configuration options.\n * @param dateLib The date library to use for date manipulation.\n * @returns The next focusable date.\n */\nexport function getFocusableDate(\n  moveBy: MoveFocusBy,\n  moveDir: MoveFocusDir,\n  refDate: Date,\n  navStart: Date | undefined,\n  navEnd: Date | undefined,\n  props: Pick<DayPickerProps, \"ISOWeek\" | \"broadcastCalendar\">,\n  dateLib: DateLib\n): Date {\n  const { ISOWeek, broadcastCalendar } = props;\n  const {\n    addDays,\n    addMonths,\n    addWeeks,\n    addYears,\n    endOfBroadcastWeek,\n    endOfISOWeek,\n    endOfWeek,\n    max,\n    min,\n    startOfBroadcastWeek,\n    startOfISOWeek,\n    startOfWeek\n  } = dateLib;\n  const moveFns = {\n    day: addDays,\n    week: addWeeks,\n    month: addMonths,\n    year: addYears,\n    startOfWeek: (date: Date) =>\n      broadcastCalendar\n        ? startOfBroadcastWeek(date, dateLib)\n        : ISOWeek\n          ? startOfISOWeek(date)\n          : startOfWeek(date),\n    endOfWeek: (date: Date) =>\n      broadcastCalendar\n        ? endOfBroadcastWeek(date)\n        : ISOWeek\n          ? endOfISOWeek(date)\n          : endOfWeek(date)\n  };\n\n  let focusableDate = moveFns[moveBy](refDate, moveDir === \"after\" ? 1 : -1);\n  if (moveDir === \"before\" && navStart) {\n    focusableDate = max([navStart, focusableDate]);\n  } else if (moveDir === \"after\" && navEnd) {\n    focusableDate = min([navEnd, focusableDate]);\n  }\n  return focusableDate;\n}\n"],"mappings":"AAOA;;;;;;;;;;;;;;;;AAgBA,OAAM,SAAUA,gBAAgBA,CAC9BC,MAAmB,EACnBC,OAAqB,EACrBC,OAAa,EACbC,QAA0B,EAC1BC,MAAwB,EACxBC,KAA4D,EAC5DC,OAAgB;EAEhB,MAAM;IAAEC,OAAO;IAAEC;EAAiB,CAAE,GAAGH,KAAK;EAC5C,MAAM;IACJI,OAAO;IACPC,SAAS;IACTC,QAAQ;IACRC,QAAQ;IACRC,kBAAkB;IAClBC,YAAY;IACZC,SAAS;IACTC,GAAG;IACHC,GAAG;IACHC,oBAAoB;IACpBC,cAAc;IACdC;EAAW,CACZ,GAAGd,OAAO;EACX,MAAMe,OAAO,GAAG;IACdC,GAAG,EAAEb,OAAO;IACZc,IAAI,EAAEZ,QAAQ;IACda,KAAK,EAAEd,SAAS;IAChBe,IAAI,EAAEb,QAAQ;IACdQ,WAAW,EAAGM,IAAU,IACtBlB,iBAAiB,GACbU,oBAAoB,CAACQ,IAAI,EAAEpB,OAAO,CAAC,GACnCC,OAAO,GACLY,cAAc,CAACO,IAAI,CAAC,GACpBN,WAAW,CAACM,IAAI,CAAC;IACzBX,SAAS,EAAGW,IAAU,IACpBlB,iBAAiB,GACbK,kBAAkB,CAACa,IAAI,CAAC,GACxBnB,OAAO,GACLO,YAAY,CAACY,IAAI,CAAC,GAClBX,SAAS,CAACW,IAAI;GACvB;EAED,IAAIC,aAAa,GAAGN,OAAO,CAACrB,MAAM,CAAC,CAACE,OAAO,EAAED,OAAO,KAAK,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;EAC1E,IAAIA,OAAO,KAAK,QAAQ,IAAIE,QAAQ,EAAE;IACpCwB,aAAa,GAAGX,GAAG,CAAC,CAACb,QAAQ,EAAEwB,aAAa,CAAC,CAAC;EAChD,CAAC,MAAM,IAAI1B,OAAO,KAAK,OAAO,IAAIG,MAAM,EAAE;IACxCuB,aAAa,GAAGV,GAAG,CAAC,CAACb,MAAM,EAAEuB,aAAa,CAAC,CAAC;EAC9C;EACA,OAAOA,aAAa;AACtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}