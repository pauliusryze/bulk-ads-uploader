{"ast":null,"code":"import { useLayoutEffect, useRef } from \"react\";\nimport { Animation } from \"./UI.js\";\nconst asHtmlElement = element => {\n  if (element instanceof HTMLElement) return element;\n  return null;\n};\nconst queryMonthEls = element => [...(element.querySelectorAll(\"[data-animated-month]\") ?? [])];\nconst queryMonthEl = element => asHtmlElement(element.querySelector(\"[data-animated-month]\"));\nconst queryCaptionEl = element => asHtmlElement(element.querySelector(\"[data-animated-caption]\"));\nconst queryWeeksEl = element => asHtmlElement(element.querySelector(\"[data-animated-weeks]\"));\nconst queryNavEl = element => asHtmlElement(element.querySelector(\"[data-animated-nav]\"));\nconst queryWeekdaysEl = element => asHtmlElement(element.querySelector(\"[data-animated-weekdays]\"));\n/**\n * Handles animations for transitioning between months in the DayPicker\n * component.\n *\n * @private\n * @param rootElRef - A reference to the root element of the DayPicker\n *   component.\n * @param enabled - Whether animations are enabled.\n * @param options - Configuration options for the animation, including class\n *   names, months, focused day, and the date utility library.\n */\nexport function useAnimation(rootElRef, enabled, _ref) {\n  let {\n    classNames,\n    months,\n    focused,\n    dateLib\n  } = _ref;\n  const previousRootElSnapshotRef = useRef(null);\n  const previousMonthsRef = useRef(months);\n  const animatingRef = useRef(false);\n  useLayoutEffect(() => {\n    // get previous months before updating the previous months ref\n    const previousMonths = previousMonthsRef.current;\n    // update previous months ref for next effect trigger\n    previousMonthsRef.current = months;\n    if (!enabled || !rootElRef.current ||\n    // safety check because the ref can be set to anything by consumers\n    !(rootElRef.current instanceof HTMLElement) ||\n    // validation required for the animation to work as expected\n    months.length === 0 || previousMonths.length === 0 || months.length !== previousMonths.length) {\n      return;\n    }\n    const isSameMonth = dateLib.isSameMonth(months[0].date, previousMonths[0].date);\n    const isAfterPreviousMonth = dateLib.isAfter(months[0].date, previousMonths[0].date);\n    const captionAnimationClass = isAfterPreviousMonth ? classNames[Animation.caption_after_enter] : classNames[Animation.caption_before_enter];\n    const weeksAnimationClass = isAfterPreviousMonth ? classNames[Animation.weeks_after_enter] : classNames[Animation.weeks_before_enter];\n    // get previous root element snapshot before updating the snapshot ref\n    const previousRootElSnapshot = previousRootElSnapshotRef.current;\n    // update snapshot for next effect trigger\n    const rootElSnapshot = rootElRef.current.cloneNode(true);\n    if (rootElSnapshot instanceof HTMLElement) {\n      // if this effect is triggered while animating, we need to clean up the new root snapshot\n      // to put it in the same state as when not animating, to correctly animate the next month change\n      const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);\n      currentMonthElsSnapshot.forEach(currentMonthElSnapshot => {\n        if (!(currentMonthElSnapshot instanceof HTMLElement)) return;\n        // remove the old month snapshots from the new root snapshot\n        const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);\n        if (previousMonthElSnapshot && currentMonthElSnapshot.contains(previousMonthElSnapshot)) {\n          currentMonthElSnapshot.removeChild(previousMonthElSnapshot);\n        }\n        // remove animation classes from the new month snapshots\n        const captionEl = queryCaptionEl(currentMonthElSnapshot);\n        if (captionEl) {\n          captionEl.classList.remove(captionAnimationClass);\n        }\n        const weeksEl = queryWeeksEl(currentMonthElSnapshot);\n        if (weeksEl) {\n          weeksEl.classList.remove(weeksAnimationClass);\n        }\n      });\n      previousRootElSnapshotRef.current = rootElSnapshot;\n    } else {\n      previousRootElSnapshotRef.current = null;\n    }\n    if (animatingRef.current || isSameMonth ||\n    // skip animation if a day is focused because it can cause issues to the animation and is better for a11y\n    focused) {\n      return;\n    }\n    const previousMonthEls = previousRootElSnapshot instanceof HTMLElement ? queryMonthEls(previousRootElSnapshot) : [];\n    const currentMonthEls = queryMonthEls(rootElRef.current);\n    if (currentMonthEls && currentMonthEls.every(el => el instanceof HTMLElement) && previousMonthEls && previousMonthEls.every(el => el instanceof HTMLElement)) {\n      animatingRef.current = true;\n      const cleanUpFunctions = [];\n      // set isolation to isolate to isolate the stacking context during animation\n      rootElRef.current.style.isolation = \"isolate\";\n      // set z-index to 1 to ensure the nav is clickable over the other elements being animated\n      const navEl = queryNavEl(rootElRef.current);\n      if (navEl) {\n        navEl.style.zIndex = \"1\";\n      }\n      currentMonthEls.forEach((currentMonthEl, index) => {\n        const previousMonthEl = previousMonthEls[index];\n        if (!previousMonthEl) {\n          return;\n        }\n        // animate new displayed month\n        currentMonthEl.style.position = \"relative\";\n        currentMonthEl.style.overflow = \"hidden\";\n        const captionEl = queryCaptionEl(currentMonthEl);\n        if (captionEl) {\n          captionEl.classList.add(captionAnimationClass);\n        }\n        const weeksEl = queryWeeksEl(currentMonthEl);\n        if (weeksEl) {\n          weeksEl.classList.add(weeksAnimationClass);\n        }\n        // animate new displayed month end\n        const cleanUp = () => {\n          animatingRef.current = false;\n          if (rootElRef.current) {\n            rootElRef.current.style.isolation = \"\";\n          }\n          if (navEl) {\n            navEl.style.zIndex = \"\";\n          }\n          if (captionEl) {\n            captionEl.classList.remove(captionAnimationClass);\n          }\n          if (weeksEl) {\n            weeksEl.classList.remove(weeksAnimationClass);\n          }\n          currentMonthEl.style.position = \"\";\n          currentMonthEl.style.overflow = \"\";\n          if (currentMonthEl.contains(previousMonthEl)) {\n            currentMonthEl.removeChild(previousMonthEl);\n          }\n        };\n        cleanUpFunctions.push(cleanUp);\n        // animate old displayed month\n        previousMonthEl.style.pointerEvents = \"none\";\n        previousMonthEl.style.position = \"absolute\";\n        previousMonthEl.style.overflow = \"hidden\";\n        previousMonthEl.setAttribute(\"aria-hidden\", \"true\");\n        // hide the weekdays container of the old month and only the new one\n        const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);\n        if (previousWeekdaysEl) {\n          previousWeekdaysEl.style.opacity = \"0\";\n        }\n        const previousCaptionEl = queryCaptionEl(previousMonthEl);\n        if (previousCaptionEl) {\n          previousCaptionEl.classList.add(isAfterPreviousMonth ? classNames[Animation.caption_before_exit] : classNames[Animation.caption_after_exit]);\n          previousCaptionEl.addEventListener(\"animationend\", cleanUp);\n        }\n        const previousWeeksEl = queryWeeksEl(previousMonthEl);\n        if (previousWeeksEl) {\n          previousWeeksEl.classList.add(isAfterPreviousMonth ? classNames[Animation.weeks_before_exit] : classNames[Animation.weeks_after_exit]);\n        }\n        currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);\n      });\n    }\n  });\n}","map":{"version":3,"names":["useLayoutEffect","useRef","Animation","asHtmlElement","element","HTMLElement","queryMonthEls","querySelectorAll","queryMonthEl","querySelector","queryCaptionEl","queryWeeksEl","queryNavEl","queryWeekdaysEl","useAnimation","rootElRef","enabled","_ref","classNames","months","focused","dateLib","previousRootElSnapshotRef","previousMonthsRef","animatingRef","previousMonths","current","length","isSameMonth","date","isAfterPreviousMonth","isAfter","captionAnimationClass","caption_after_enter","caption_before_enter","weeksAnimationClass","weeks_after_enter","weeks_before_enter","previousRootElSnapshot","rootElSnapshot","cloneNode","currentMonthElsSnapshot","forEach","currentMonthElSnapshot","previousMonthElSnapshot","contains","removeChild","captionEl","classList","remove","weeksEl","previousMonthEls","currentMonthEls","every","el","cleanUpFunctions","style","isolation","navEl","zIndex","currentMonthEl","index","previousMonthEl","position","overflow","add","cleanUp","push","pointerEvents","setAttribute","previousWeekdaysEl","opacity","previousCaptionEl","caption_before_exit","caption_after_exit","addEventListener","previousWeeksEl","weeks_before_exit","weeks_after_exit","insertBefore","firstChild"],"sources":["/Users/paulius/Downloads/Projects/Meta Ads Uploader/frontend/node_modules/react-day-picker/src/useAnimation.ts"],"sourcesContent":["import React, { useLayoutEffect, useRef } from \"react\";\n\nimport { Animation } from \"./UI.js\";\nimport type { CalendarDay } from \"./classes/CalendarDay.js\";\nimport { CalendarMonth } from \"./classes/CalendarMonth.js\";\nimport type { DateLib } from \"./classes/DateLib.js\";\nimport { ClassNames } from \"./types/shared.js\";\n\nconst asHtmlElement = (element: Element | null): HTMLElement | null => {\n  if (element instanceof HTMLElement) return element;\n  return null;\n};\n\nconst queryMonthEls = (element: HTMLElement) => [\n  ...(element.querySelectorAll(\"[data-animated-month]\") ?? [])\n];\nconst queryMonthEl = (element: HTMLElement) =>\n  asHtmlElement(element.querySelector(\"[data-animated-month]\"));\nconst queryCaptionEl = (element: HTMLElement) =>\n  asHtmlElement(element.querySelector(\"[data-animated-caption]\"));\nconst queryWeeksEl = (element: HTMLElement) =>\n  asHtmlElement(element.querySelector(\"[data-animated-weeks]\"));\nconst queryNavEl = (element: HTMLElement) =>\n  asHtmlElement(element.querySelector(\"[data-animated-nav]\"));\nconst queryWeekdaysEl = (element: HTMLElement) =>\n  asHtmlElement(element.querySelector(\"[data-animated-weekdays]\"));\n\n/**\n * Handles animations for transitioning between months in the DayPicker\n * component.\n *\n * @private\n * @param rootElRef - A reference to the root element of the DayPicker\n *   component.\n * @param enabled - Whether animations are enabled.\n * @param options - Configuration options for the animation, including class\n *   names, months, focused day, and the date utility library.\n */\nexport function useAnimation(\n  rootElRef: React.RefObject<HTMLDivElement | null>,\n  enabled: boolean,\n  {\n    classNames,\n    months,\n    focused,\n    dateLib\n  }: {\n    classNames: ClassNames;\n    months: CalendarMonth[];\n    focused: CalendarDay | undefined;\n    dateLib: DateLib;\n  }\n): void {\n  const previousRootElSnapshotRef = useRef<HTMLElement>(null);\n  const previousMonthsRef = useRef(months);\n  const animatingRef = useRef(false);\n\n  useLayoutEffect(() => {\n    // get previous months before updating the previous months ref\n    const previousMonths = previousMonthsRef.current;\n    // update previous months ref for next effect trigger\n    previousMonthsRef.current = months;\n\n    if (\n      !enabled ||\n      !rootElRef.current ||\n      // safety check because the ref can be set to anything by consumers\n      !(rootElRef.current instanceof HTMLElement) ||\n      // validation required for the animation to work as expected\n      months.length === 0 ||\n      previousMonths.length === 0 ||\n      months.length !== previousMonths.length\n    ) {\n      return;\n    }\n\n    const isSameMonth = dateLib.isSameMonth(\n      months[0].date,\n      previousMonths[0].date\n    );\n\n    const isAfterPreviousMonth = dateLib.isAfter(\n      months[0].date,\n      previousMonths[0].date\n    );\n\n    const captionAnimationClass = isAfterPreviousMonth\n      ? classNames[Animation.caption_after_enter]\n      : classNames[Animation.caption_before_enter];\n\n    const weeksAnimationClass = isAfterPreviousMonth\n      ? classNames[Animation.weeks_after_enter]\n      : classNames[Animation.weeks_before_enter];\n\n    // get previous root element snapshot before updating the snapshot ref\n    const previousRootElSnapshot = previousRootElSnapshotRef.current;\n\n    // update snapshot for next effect trigger\n    const rootElSnapshot = rootElRef.current.cloneNode(true);\n    if (rootElSnapshot instanceof HTMLElement) {\n      // if this effect is triggered while animating, we need to clean up the new root snapshot\n      // to put it in the same state as when not animating, to correctly animate the next month change\n      const currentMonthElsSnapshot = queryMonthEls(rootElSnapshot);\n      currentMonthElsSnapshot.forEach((currentMonthElSnapshot) => {\n        if (!(currentMonthElSnapshot instanceof HTMLElement)) return;\n\n        // remove the old month snapshots from the new root snapshot\n        const previousMonthElSnapshot = queryMonthEl(currentMonthElSnapshot);\n        if (\n          previousMonthElSnapshot &&\n          currentMonthElSnapshot.contains(previousMonthElSnapshot)\n        ) {\n          currentMonthElSnapshot.removeChild(previousMonthElSnapshot);\n        }\n\n        // remove animation classes from the new month snapshots\n        const captionEl = queryCaptionEl(currentMonthElSnapshot);\n        if (captionEl) {\n          captionEl.classList.remove(captionAnimationClass);\n        }\n\n        const weeksEl = queryWeeksEl(currentMonthElSnapshot);\n        if (weeksEl) {\n          weeksEl.classList.remove(weeksAnimationClass);\n        }\n      });\n\n      previousRootElSnapshotRef.current = rootElSnapshot;\n    } else {\n      previousRootElSnapshotRef.current = null;\n    }\n\n    if (\n      animatingRef.current ||\n      isSameMonth ||\n      // skip animation if a day is focused because it can cause issues to the animation and is better for a11y\n      focused\n    ) {\n      return;\n    }\n\n    const previousMonthEls =\n      previousRootElSnapshot instanceof HTMLElement\n        ? queryMonthEls(previousRootElSnapshot)\n        : [];\n\n    const currentMonthEls = queryMonthEls(rootElRef.current);\n\n    if (\n      currentMonthEls &&\n      currentMonthEls.every((el) => el instanceof HTMLElement) &&\n      previousMonthEls &&\n      previousMonthEls.every((el) => el instanceof HTMLElement)\n    ) {\n      animatingRef.current = true;\n      const cleanUpFunctions: (() => void)[] = [];\n\n      // set isolation to isolate to isolate the stacking context during animation\n      rootElRef.current.style.isolation = \"isolate\";\n      // set z-index to 1 to ensure the nav is clickable over the other elements being animated\n      const navEl = queryNavEl(rootElRef.current);\n      if (navEl) {\n        navEl.style.zIndex = \"1\";\n      }\n\n      currentMonthEls.forEach((currentMonthEl, index) => {\n        const previousMonthEl = previousMonthEls[index];\n\n        if (!previousMonthEl) {\n          return;\n        }\n\n        // animate new displayed month\n        currentMonthEl.style.position = \"relative\";\n        currentMonthEl.style.overflow = \"hidden\";\n        const captionEl = queryCaptionEl(currentMonthEl);\n        if (captionEl) {\n          captionEl.classList.add(captionAnimationClass);\n        }\n\n        const weeksEl = queryWeeksEl(currentMonthEl);\n        if (weeksEl) {\n          weeksEl.classList.add(weeksAnimationClass);\n        }\n        // animate new displayed month end\n\n        const cleanUp = () => {\n          animatingRef.current = false;\n\n          if (rootElRef.current) {\n            rootElRef.current.style.isolation = \"\";\n          }\n          if (navEl) {\n            navEl.style.zIndex = \"\";\n          }\n\n          if (captionEl) {\n            captionEl.classList.remove(captionAnimationClass);\n          }\n          if (weeksEl) {\n            weeksEl.classList.remove(weeksAnimationClass);\n          }\n          currentMonthEl.style.position = \"\";\n          currentMonthEl.style.overflow = \"\";\n          if (currentMonthEl.contains(previousMonthEl)) {\n            currentMonthEl.removeChild(previousMonthEl);\n          }\n        };\n        cleanUpFunctions.push(cleanUp);\n\n        // animate old displayed month\n        previousMonthEl.style.pointerEvents = \"none\";\n        previousMonthEl.style.position = \"absolute\";\n        previousMonthEl.style.overflow = \"hidden\";\n        previousMonthEl.setAttribute(\"aria-hidden\", \"true\");\n\n        // hide the weekdays container of the old month and only the new one\n        const previousWeekdaysEl = queryWeekdaysEl(previousMonthEl);\n        if (previousWeekdaysEl) {\n          previousWeekdaysEl.style.opacity = \"0\";\n        }\n\n        const previousCaptionEl = queryCaptionEl(previousMonthEl);\n        if (previousCaptionEl) {\n          previousCaptionEl.classList.add(\n            isAfterPreviousMonth\n              ? classNames[Animation.caption_before_exit]\n              : classNames[Animation.caption_after_exit]\n          );\n          previousCaptionEl.addEventListener(\"animationend\", cleanUp);\n        }\n\n        const previousWeeksEl = queryWeeksEl(previousMonthEl);\n        if (previousWeeksEl) {\n          previousWeeksEl.classList.add(\n            isAfterPreviousMonth\n              ? classNames[Animation.weeks_before_exit]\n              : classNames[Animation.weeks_after_exit]\n          );\n        }\n\n        currentMonthEl.insertBefore(previousMonthEl, currentMonthEl.firstChild);\n      });\n    }\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}